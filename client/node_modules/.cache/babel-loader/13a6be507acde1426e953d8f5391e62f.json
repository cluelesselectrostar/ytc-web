{"ast":null,"code":"/* #! /usr/bin/env node*/\nvar Parser = require('jsonparse'),\n    through = require('through');\n/*\n\n  the value of this.stack that creationix's jsonparse has is weird.\n\n  it makes this code ugly, but his problem is way harder that mine,\n  so i'll forgive him.\n\n*/\n\n\nexports.parse = function (path, map) {\n  var parser = new Parser();\n  var stream = through(function (chunk) {\n    if ('string' === typeof chunk) chunk = new Buffer(chunk);\n    parser.write(chunk);\n  }, function (data) {\n    if (data) stream.write(data);\n    stream.queue(null);\n  });\n  if ('string' === typeof path) path = path.split('.').map(function (e) {\n    if (e === '*') return true;else if (e === '') // '..'.split('.') returns an empty string\n      return {\n        recurse: true\n      };else return e;\n  });\n\n  var count = 0,\n      _key;\n\n  if (!path || !path.length) path = null;\n\n  parser.onValue = function (value) {\n    if (!this.root) stream.root = value;\n    if (!path) return;\n    var i = 0; // iterates on path\n\n    var j = 0; // iterates on stack\n\n    while (i < path.length) {\n      var key = path[i];\n      var c;\n      j++;\n\n      if (key && !key.recurse) {\n        c = j === this.stack.length ? this : this.stack[j];\n        if (!c) return;\n        if (!check(key, c.key)) return;\n        i++;\n      } else {\n        i++;\n        var nextKey = path[i];\n        if (!nextKey) return;\n\n        while (true) {\n          c = j === this.stack.length ? this : this.stack[j];\n          if (!c) return;\n\n          if (check(nextKey, c.key)) {\n            i++;\n            break;\n          }\n\n          j++;\n        }\n      }\n    }\n\n    if (j !== this.stack.length) return;\n    count++;\n    var actualPath = this.stack.slice(1).map(function (element) {\n      return element.key;\n    }).concat([this.key]);\n    var data = this.value[this.key];\n    if (null != data) if (null != (data = map ? map(data, actualPath) : data)) stream.queue(data);\n    delete this.value[this.key];\n  };\n\n  parser._onToken = parser.onToken;\n\n  parser.onToken = function (token, value) {\n    parser._onToken(token, value);\n\n    if (this.stack.length === 0) {\n      if (stream.root) {\n        if (!path) stream.queue(stream.root);\n        stream.emit('root', stream.root, count);\n        count = 0;\n        stream.root = null;\n      }\n    }\n  };\n\n  parser.onError = function (err) {\n    stream.emit('error', err);\n  };\n\n  return stream;\n};\n\nfunction check(x, y) {\n  if ('string' === typeof x) return y == x;else if (x && 'function' === typeof x.exec) return x.exec(y);else if ('boolean' === typeof x) return x;else if ('function' === typeof x) return x(y);\n  return false;\n}\n\nexports.stringify = function (op, sep, cl, indent) {\n  indent = indent || 0;\n\n  if (op === false) {\n    op = '';\n    sep = '\\n';\n    cl = '';\n  } else if (op == null) {\n    op = '[\\n';\n    sep = '\\n,\\n';\n    cl = '\\n]\\n';\n  } //else, what ever you like\n\n\n  var stream,\n      first = true,\n      anyData = false;\n  stream = through(function (data) {\n    anyData = true;\n    var json = JSON.stringify(data, null, indent);\n\n    if (first) {\n      first = false;\n      stream.queue(op + json);\n    } else stream.queue(sep + json);\n  }, function (data) {\n    if (!anyData) stream.queue(op);\n    stream.queue(cl);\n    stream.queue(null);\n  });\n  return stream;\n};\n\nexports.stringifyObject = function (op, sep, cl, indent) {\n  indent = indent || 0;\n\n  if (op === false) {\n    op = '';\n    sep = '\\n';\n    cl = '';\n  } else if (op == null) {\n    op = '{\\n';\n    sep = '\\n,\\n';\n    cl = '\\n}\\n';\n  } //else, what ever you like\n\n\n  var first = true,\n      anyData = false;\n  stream = through(function (data) {\n    anyData = true;\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent);\n\n    if (first) {\n      first = false;\n      this.queue(op + json);\n    } else this.queue(sep + json);\n  }, function (data) {\n    if (!anyData) this.queue(op);\n    this.queue(cl);\n    this.queue(null);\n  });\n  return stream;\n};\n\nif (!module.parent && process.title !== 'browser') {\n  process.stdin.pipe(exports.parse(process.argv[2])).pipe(exports.stringify('[', ',\\n', ']\\n', 2)).pipe(process.stdout);\n}","map":{"version":3,"sources":["C:/Users/yanni/Documents/App_Development/yanni-webpage/node_modules/JSONStream/index.js"],"names":["Parser","require","through","exports","parse","path","map","parser","stream","chunk","Buffer","write","data","queue","split","e","recurse","count","_key","length","onValue","value","root","i","j","key","c","stack","check","nextKey","actualPath","slice","element","concat","_onToken","onToken","token","emit","onError","err","x","y","exec","stringify","op","sep","cl","indent","first","anyData","json","JSON","stringifyObject","module","parent","process","title","stdin","pipe","argv","stdout"],"mappings":"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","sourcesContent":["/* #! /usr/bin/env node*/\n\nvar Parser = require('jsonparse')\n  , through = require('through')\n\n/*\n\n  the value of this.stack that creationix's jsonparse has is weird.\n\n  it makes this code ugly, but his problem is way harder that mine,\n  so i'll forgive him.\n\n*/\n\nexports.parse = function (path, map) {\n\n  var parser = new Parser()\n  var stream = through(function (chunk) {\n    if('string' === typeof chunk)\n      chunk = new Buffer(chunk)\n    parser.write(chunk)\n  },\n  function (data) {\n    if(data)\n      stream.write(data)\n    stream.queue(null)\n  })\n\n  if('string' === typeof path)\n    path = path.split('.').map(function (e) {\n      if (e === '*')\n        return true\n      else if (e === '') // '..'.split('.') returns an empty string\n        return {recurse: true}\n      else\n        return e\n    })\n\n\n  var count = 0, _key\n  if(!path || !path.length)\n    path = null\n\n  parser.onValue = function (value) {\n    if (!this.root)\n      stream.root = value\n\n    if(! path) return\n\n    var i = 0 // iterates on path\n    var j  = 0 // iterates on stack\n    while (i < path.length) {\n      var key = path[i]\n      var c\n      j++\n\n      if (key && !key.recurse) {\n        c = (j === this.stack.length) ? this : this.stack[j]\n        if (!c) return\n        if (! check(key, c.key)) return\n        i++\n      } else {\n        i++\n        var nextKey = path[i]\n        if (! nextKey) return\n        while (true) {\n          c = (j === this.stack.length) ? this : this.stack[j]\n          if (!c) return\n          if (check(nextKey, c.key)) { i++; break}\n          j++\n        }\n      }\n    }\n    if (j !== this.stack.length) return\n\n    count ++\n    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])\n    var data = this.value[this.key]\n    if(null != data)\n      if(null != (data = map ? map(data, actualPath) : data))\n        stream.queue(data)\n    delete this.value[this.key]\n  }\n  parser._onToken = parser.onToken;\n\n  parser.onToken = function (token, value) {\n    parser._onToken(token, value);\n    if (this.stack.length === 0) {\n      if (stream.root) {\n        if(!path)\n          stream.queue(stream.root)\n        stream.emit('root', stream.root, count)\n        count = 0;\n        stream.root = null;\n      }\n    }\n  }\n\n  parser.onError = function (err) {\n    stream.emit('error', err)\n  }\n\n\n  return stream\n}\n\nfunction check (x, y) {\n  if ('string' === typeof x)\n    return y == x\n  else if (x && 'function' === typeof x.exec)\n    return x.exec(y)\n  else if ('boolean' === typeof x)\n    return x\n  else if ('function' === typeof x)\n    return x(y)\n  return false\n}\n\nexports.stringify = function (op, sep, cl, indent) {\n  indent = indent || 0\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n\n    op = '[\\n'\n    sep = '\\n,\\n'\n    cl = '\\n]\\n'\n\n  }\n\n  //else, what ever you like\n\n  var stream\n    , first = true\n    , anyData = false\n  stream = through(function (data) {\n    anyData = true\n    var json = JSON.stringify(data, null, indent)\n    if(first) { first = false ; stream.queue(op + json)}\n    else stream.queue(sep + json)\n  },\n  function (data) {\n    if(!anyData)\n      stream.queue(op)\n    stream.queue(cl)\n    stream.queue(null)\n  })\n\n  return stream\n}\n\nexports.stringifyObject = function (op, sep, cl, indent) {\n  indent = indent || 0\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n\n    op = '{\\n'\n    sep = '\\n,\\n'\n    cl = '\\n}\\n'\n\n  }\n\n  //else, what ever you like\n\n  var first = true\n    , anyData = false\n  stream = through(function (data) {\n    anyData = true\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)\n    if(first) { first = false ; this.queue(op + json)}\n    else this.queue(sep + json)\n  },\n  function (data) {\n    if(!anyData) this.queue(op)\n    this.queue(cl)\n\n    this.queue(null)\n  })\n\n  return stream\n}\n\nif(!module.parent && process.title !== 'browser') {\n  process.stdin\n    .pipe(exports.parse(process.argv[2]))\n    .pipe(exports.stringify('[', ',\\n', ']\\n', 2))\n    .pipe(process.stdout)\n}\n"]},"metadata":{},"sourceType":"script"}